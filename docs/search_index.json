[
["index.html", "Android Development: Lecture Notes About this Book", " Android Development: Lecture Notes Joel Ross 2017-03-20 About this Book This book compiles lecture notes and tutorials for the INFO 448 Mobile Development: Android course taught at the University of Washington Information School (most recently in Spring 2017). The goal of these notes is to provide learning materials for students in the course or anyone else who wishes to learn the basics of developing Android applications. These notes are primarily adapted from the official Android developer documentation, compiling and synthesizing those guidelines for pedagogical purposes (and the author’s own interpretation/biases). Please refer to that documentation for the latest information and official guidance. This book is currently in alpha status, as pure lecture notes are converted into more generic formats. This book is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["introduction.html", "1 Introduction 1.1 Android History 1.2 Android Architecture and Code 1.3 Development Tools 1.4 Hello World", " 1 Introduction Start off with a question: What is Android? Why did you sign up for a course called Android Development? It’s an Operating System! That is, it’s software that connects hardware to software and provides general services. More than that, it’s a mobile specific operating system. “Android” also refers to “platform” (e.g., devices that use the OS) and the ecosystem that surrounds it. This includes the device manufacturers who use the platform, and the applications that can be built and run on this platform. 1.1 Android History Some brief history: 2003: founded by “Android Inc” to build mobile OS operating system (similar to what Symbian (Nokia) was doing) 2005: acquired by Google, who was looking to get into mobile 2007: Google announces Open Handset Alliance, group of tech companies working together to develop “open standards” Google; HTC, Samsung, Sony; T-Mobile, Sprint NTT DoCoMo; Broadcom, Nvidia, etc. Now 84 companies. Note this is the same year the first iPhone came out! 2008: First Android device (HTC Dream / T-Mobile G1) 528Mhz ARM chip; 256MB memory; 320x480 resolution capacitive touch; slide-out keyboard! A fun little device 2010: First Nexus device: Google-developed “flagship” devices Nexus One: 1Gz Scorpion; 512MB memory; .37&quot; 480x800 AMOLED capacitive touch Comparison: iPhone 6S+ (1.85Ghz dual core ARMv8, 2GB RAM, 5.5&quot; @ 1920x1080) 2014: Android One (low-cost for developing countries) 2015: Project Brillo, aiming for embedded devices Android is incredibly popular! (see e.g., here, here, here) There are some questions about what is counted… but what we care about is that there are a lot of Android devices out there! More than that, there are a lot of different devices! For version history, reference the Wiki chart - Different “versions” are named after desserts. But from developer perspective, care about API version (e.g., what set of interfaces are available). - Interactive version: http://www.android.com/history/ - Usage breakdown at: http://developer.android.com/about/dashboards/index.html Updates to devices historically through purchasing new devices (every 18m on average in US). Otherwise updates–including security updates–come through carriers. This is a problem from a consumer perspective! But Google working to change that; moving some services out of OS into separate “App” (Google Play Services). - Android OS is “open source”; latest version at https://source.android.com/. Worth actually digging around in this sometime Would be remiss if didn’t mention some of the legal issues surrounding Android. Biggest is Oracle v Google: basics is that Oracle says the Java API is copyright, so because Google uses that API is Android, Google is violating the copyright Claim: the method signatures themselves (and how they work) are protected! CA court decided for Google in 2012 (can’t copyright an API!); reversed by Federal Circuit in 2014. Supreme Court refused to hear in 2015. https://www.eff.org/cases/oracle-v-google for more Also https://arstechnica.com/series/series-oracle-v-google/ Interesting development: latest version of Android (Nougat) uses the OpenJDK implementation of Java, instead of Google own see here. Shouldn’t impact us, but keep an eye out for potential differences between Android and Java SE. Others as well: Apple v Samsung: “You infringed our intellectual property!” (Supreme court sides with Samsung) FairSearch v Google: “You’re using predatory pricing!” Take away: Android is a growing, evolving platform that is embedded in and affecting the social infrastructures around information technology. 1.2 Android Architecture and Code Let’s consider the basic architecture of the Android platform (More details: https://source.android.com/devices/) Runs on a linux kernel (for interacting with memory, processor, etc) On top of that is the hardware abstraction layer: interface to drivers that let us access the hardware (camera, storage, wifi, etc) These drivers are generally written in C But on top of that is the Runtime and Android Framework, which provides the Java language that we all know and love! (We’ll be developing applications that interact with the Framework, which runs on Java). There are two languages we’ll be working with in this class: Java. Android code (the logic, control, data stuff) is written in Java. This will feel a lot like every other Java Program: you write classes, define methods, instantiate objects, and call methods on those objects But we’re working within a framework: a set of code already exists to call specific methods: we’ll just fill in what those methods do to run our code More Angular (framework) than jQuery (library) Important: This course expects you to have “journeyman”-level skills in Java (apprenticeship done, not yet master). We’ll be using a number of intermediate concepts (like generics and inheritance) without much fanfare or explanation. And so you should be comfortable with that. If you’re not… this class is going to be a challenge. Consider yourselves warned. We will go over some of the topics that people reported being less familiar with tomorrow in lab… but that will be most our Java review. I’m assuming you’re already comfortable with the language so that we can focus on the framework. By the way: for reviewing; rather do a “work through a tutorial/explanation” or have me lecture/review topics? (e.g., do you want to drive or do you want me to?) Any questions/concerns/issues about that XML. Android interfaces and resources are specified in XML (eXtensible Markup Language). So we’ll be doing a lot of XML writing. XML is just like HTML, but you get to make up your own tags (though we’re going to use the ones that Android made up). If you’ve never worked with HTML… you’ll pick it up fast (it’s not complex). If you think of web programming: the XML is going to contain what we would put in our HTML/CSS, and the Java will contain what would go in our JavaScript. Building Apps: So we write code in Java &amp; XML. How does that get run on the phone’s hardware? Pre-Lollipop (5.0): used Dalvik, a virtual machine (similar to the JVM from Java SE) Java code –compile–&gt; JVM bytecode –translated–&gt; DVM bytecode stored in DEX or ODEX files (“[optimized] Dalvik executables”) process is called “dexing” (so code is “dexed”) For CS people: Dalvik register-based architecture (not stack-based!) Dalvik Includes JIT compilation to native code (like the Java HotSpot) Why would “native code” be faster? Because no translation step is needed to talk to the actual hardware (the OS) Post-Lollipop (5.0): uses Android Runtime (ART) compile into native code on installation! (“Ahead of Time” AOT) accepts DEX bytecode for backwards compatibility faster execution, but longer install time Android applications are packaged into APK files (basically zip files) Which are then “side-loaded” or cryptographically signed to be uploaded to the App Store. these are the “executable” versions of your program! Note: application frameworks are pre-DEXed (compiled) on device; actually compiling against empty stubs! But any other libraries you include are copied into the app code. So when building an App… Generate Java source files (e.g., from resource files, which are written XML used to generate Java code) Compile Java code into JVM bytecode “dex” the JVM bytecode into Dalvik bytecode Pack in assets and graphics into an APK Cryptographically sign the APK file to verify it There are a lot of steps here, but there are tools that take care of it for us. We’ll just write Java and XML code and run a “build” script to do all of the steps. 1.3 Development Tools Since we’re writing code for a virtual machine anyway, we can build Android apps on any computer OS (unlike some other mobile OS) Physical devices are the best–you’ll need USB cable to be able to wire your device into your computer. Any device should be fine; don’t need cell service (just WiFi mostly) If you don’t normally use an Android phone, play around with it a bit to get use to the interaction language. E.g., how to click/swipe/drag/long-click things. Turn on developer options! Also can use the Emulator (a “virtual” android device) Represents a generic device with hardware you can specify… but has some limitations! But the emulator not great on Windows; recommend you use Mac or a physical device Make sure to use the HAXM (Intel acceleration manager!) I’ll be doing this for lecture demos (will keep me running slower than you!) 1.3.1 Software The software used to develop Android applications include: Java 7 SDK Gradle or Apache ANT These are automated build tools–in effect, they let you specify a command that will do a bunch of steps (e.g., compilation, moving, etc) at once. These are how we make the “build script” to do those 5 building steps from earlier. ANT is the old way, but Gradle is the new hotness You’ll be using Gradle for first homework (Java review), and we’ll be poking at it periodically through the course. We’ll be doing minor tweaks to build files, not learning the entirety of the gradle build system (though as you get into professional development systems you’ll want to check them out) Finally, the Android Studio &amp; SDK. This is our IDE and build system (everything else goes to support this). Make sure the SDK command-line tools are installed! put tools and platform-tools on the PATH run adb to check SDK Tools include: deprecated android: does SDK/AVD (virtual device) work. Basically IDE commands, but from command-line emulator runs the emulator adb “Android Device Bridge”; connection between your computer and the device (physical or virtual). Used for console output! all of these are built into IDE, but command-line is a good fall-back! 1.4 Hello World In time remaining, lets get an App up and running and see what we actually will be working with! You will need to have Android Studio installed for this to work. Launch Android Studio if you have it (may take a few minutes to open) Start a new project! use uwnetid in domain note project location! Desktop is good for now Target: this is the “minimum” SDK you support. Going to target Ice Cream Sandwich (4.0.3) for most this class. This is the earliest version we’ll support. Note that this is different than the “target SDK”, which is the version you tested on! We’ll adjust this in a moment, and will test on API 21 (Lollipop). If you’re testing on a physical device running older version, you can target that. But we’ll grade at the 5.0 target. Select an Empty Activity Activities are “Screens” in your application (things the user can do). We’ll talk more about this on Wednesday. And boom, have an Android app! Aren’t frameworks lovely? 1.4.1 The Emulator We can run our app by clicking the “Play” or “Run” button. We will need to define a device, so let’s make an emulator! Nexus 5 is a good choice for supporting “older” devices. Pixel is also reasonable. Use Lollipop, Google APIs, x86! Snapshot to speed up loading Specify hardware keyboard Want to go in and edit it (Tools &gt; Android &gt; AVD Manager) so it accepts keyboard input! Can slide to unlock, and there is our app! 1.4.2 Project Contents So what does our app look like in code? What do we have? Note that Android Studio by default shows the “Android” view, which organizes files thematically. If you got the “Project” view you can see what the actual file system looks like. app/ folder contains our application manifests/ contains the Android Manifest files, which is sort of like a “config” file for the app java/ contains the Java source code for your project And we can find the MyActivity file in here res/ contains resource files used in the app. These are where we’re going to put layout/appearance information Also have the Gradle scripts. There are a lot of these: build.gradle: Top-level Gradle build; project-level (for building!) app/build.gradle: Gradle build specific to the app use this one to customize project! we can change the target SDK here! proguard-rules.pro: config for release version (minimization, obfuscation, etc). gradle.properties: Gradle-specific build settings, shared local.properties: settings local to this machine only settings.gradle: Gradle-specific build settings, shared ANT would give: build.xml: Ant build script integrated with Android SDK build.properties: settings used for build across all machines local.properties: settings local to this machine only We’re using Gradle, but be aware of ANT stuff for legacy purposes res has resource files. These are XML files that specify details of the app–such as layout. res/drawable/ : graphics (PNG, JPEG, etc) res/layout/ : UI XML layout files res/mipmap/ : launcher icon files fun fact: MIP comes from “multum in parvo”, latin for “much in little”. Map cause image mapping res/values/ : general constants See also: http://developer.android.com/guide/topics/resources/available-resources.html We’ll talk about these more next week! Let’s look at what the application does. We’ll revisit this on Wednesday, but this will let us start seeing how the framework is structured. We start with the Activity Java source We extend Activity (actually a subclass that supports Material Design stuff), making our own customizations. Override onCreate() method that is called by the framework when the Activity starts (more on lifecycle tomorrow). Call super, and then setContentView to specify what the content (appearance) of our activity is. Passing in a value from something called R. What type of thing is this? (It’s a class!) R is a class that is generated at compile time and contains constants that are defined by the “resource” files! Those files are converted into Java variables, which we access through the R class. R.layout refers to the “layouts” resource, so can go there. Can open then up in “design” view. This lets you use GUIs to lay out your application (like a powerpoint slide). But frowned upon–much cleaner/nicer to write it out in code. Same difference between writing your own HTML and using FrontPage or DreamWeaver or Wix. Legit, but less nice. We can see the XML: tags, attributes, values. Tags nested inside one another. Defines a layout, and inside that is a TextView (view of some of text), which has a value–text! Can change that, and re-run the app! If time: can also define this in values/strings (e.g., as a constant, refer to as @string/message) We’ll talk about the layout and using these resources A LOT more next week. If time: we can also set an icon! (File &gt; New &gt; Image Asset) "]
]
