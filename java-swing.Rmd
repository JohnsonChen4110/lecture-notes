# Swing Framework `r #30min`
Android applications are user-driven graphical applications. So to look at some of the _patterns_ involved in this kind of software (without the overhead of the Android framework), let's consider how to build simple graphical applications in Java using the [Swing library](https://docs.oracle.com/javase/tutorial/uiswing/start/)
- We're going to be doing a little bit of Java programming; easiest to just do this in Sublime Text or whatever light-weight IDE you have floating around.

The **Swing** library is a set of Java classes used to specify graphical user interfaces (GUIs). These classes can be found in the [`javax.swing`](https://docs.oracle.com/javase/8/docs/api/javax/swing/package-summary.html) package. They also rely on the [`java.awt`](https://docs.oracle.com/javase/8/docs/api/java/awt/package-summary.html) package (the "Advanced Windowing Toolkit"), which is an older GUI library that Swing builds on top of.
- Fun fact: Swing library is named after the dance style: the developers wanted to name it after something hip and cool and popular. In the mid-90s.

Let's look at an incredibly basic GUI class: `MyGUI` found in the `src/main/java/` folder. Things to note about this class:

- The class subclasses [`JFrame`](https://docs.oracle.com/javase/8/docs/api/javax/swing/JFrame.html). `JFrame` represents a "window" in your operating system, and does all the work of making that window show up and interact with the operating system in a normal way. By subclassing `JFrame`, we get that functionality for free! this is how we build all GUI applications.

	- We call the parent constructor (passing in the title for the window), and then specify what happens when we hit the "close" button.
- We then instantiate a [`JButton`](https://docs.oracle.com/javase/8/docs/api/javax/swing/JButton.html), which is a Java button

	- Note that `JButton` is the Swing version of a button, building off of the older `java.awt.Button` class.
- We then `.add()` this button to the `JFrame`. This puts the button inside the Window. A little but like using jQuery to add some HTML to the page.

- Finally, we call `.pack()` to tell the Frame to resize itself to fit the contents, and then `.setVisible()` to make it actually appear.

- We run this program from `main` by just instantiating our specialized `JFrame`, which will contain the button.

We can compile and run it with `./gradlew -q run`. And voila, we have a basic button!

## Events
If we click the button... nothing happens. Let's make it print out a message when clicked. We can do this through **event-based programming** (if you remember `onClick` events from JavaScript, this is the same idea).

The computer sees interactions with its GUI as a series of **events**. The event of clicking a button. The event of moving the mouse. The event of closing a window. Etc. Each thing you interact with _generates_ and _emits_ these events. So when you click on a button, it creates and emits an "I was clicked!" event.
- You can think of this like the button shouting "Hey hey! I was pressed!" We can then respond to this shouting to have our program do something when the button is clicked.

Events, like everything else in Java, are Objects (of the [`EventObject`](https://docs.oracle.com/javase/8/docs/api/java/util/EventObject.html) type) that are created by the emitter. A `JButton` in particular emits [`ActionEvents`](https://docs.oracle.com/javase/8/docs/api/java/awt/event/ActionEvent.html) when pressed (the "action" being that it was pressed).
- When buttons are pressed, they shout out `ActionEvents`

In order to respond to this shouting, we need to "listen" for these events. Then whenever we hear that there is an event happening, we can react to it.
- This is like a person manning a submarine radar. Or hooking up a baby monitor. Or following someone on Twitter, in a way.

But this is Java, so we need an object to listen for these events: a "listener" if you will. Luckily, Java provides a type that can listen for `ActionEvents`: [`ActionListener`](https://docs.oracle.com/javase/8/docs/api/java/awt/event/ActionListener.html). This type has an `actionPerformed()` method that can be called in response to an event.
- We use the [Observer Pattern](https://sourcemaking.com/design_patterns/observer) to connect this listener object to the button (`button.addActionListener(listener)`). This _registers_ the listener, so that the Button knows who to shout at when something happens. Again, like following someone on Twitter. When the button is pressed, it will go to any listeners registered with it and call their `actionPerformed()` methods, passing in the `ActionEvent` it generated.

Look again: is `ActionListener` a class? No, it's an interface! Which means if we want to make an `ActionListener` object, we need to create a class that implements this interface (and provides the `actionPerformed()` method that can be called when the event occurs). There are a few ways we can do this:

1. Well we already have a class we're developing: `MyGUI`! So let's just make _that_ class `implement ActionListener`. We'll fill in the provided method, and then specify that `this` object is the listener, and voila.
	- This is my favorite way to create listeners in Java (since it keeps everything self-contained: the `JFrame` handles the events its buttons produce).
	- We'll utilize a variant of this pattern in Android: we'll make classes implement listeners, and then "register" that listener somewhere else in the code (often in a nested class).

2. But what if we want to reuse our listener across different classes, but don't want to have to create a new `MyGUI` object to listen for a button to be clicked? We can instead use an **inner** or **nested** class. For example, a nested class `MyActionListener` that implements the interface, and then just instantiate one of these to register with the button.
	- This could be a `static` nested class, but then we can't have it access instance variables (because it belongs to the _class_, not the _object_). So might make it an inner class. Of course then we can't re-use it elsewhere without making the `MyGUI`... but at least we've organized the functionality a bit.

3. It seems sort of silly to create a whole new `MyActionListener` class that has one method and is just going to be instantiated once. So what if instead of giving it a name, we just made it an [**anonymous class**](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)?
	- Like how we've made _anonymous variables_ by instantiating objects without assigning them to named variables... we can do the same thing with a class that just implements an interface. The syntax looks like:
		```java
		button.addActionListener(new ActionListener() {
			//class declaration goes here!

			public void actionPerformed(ActionEvent) { /*...*/}
		});
		```
	- This is how buttons are often used in Android: we'll create an anonymous listener object to respond to the event that occurs when they are pressed.

Questions on this kind of event-driven programming?

## Layouts and Composites `r #[end by 11:10]`
One more piece if we have time: what if we want to add a second button? If we try to just `.add()` another button... it replaces the one we just had! This is because Java doesn't know _where_ to put the second button. Below? Above? Left? Right?

In order to have the `JFrame` contain multiple components, we need to specify a [**layout**](https://docs.oracle.com/javase/8/docs/api/java/awt/LayoutManager.html), which knows how to organize items that are added to the Frame. We do this with the `.setLayout()` method. For example, we can give the frame a `BoxLayout()` with a `PAGE_AXIS` orientation to have it lay out the buttons in a vertical row.
- Java has different `LayoutManagers` that each have their own way of organizing components. We'll see this same idea in Android (and talk about Android's layout system in _a lot_ more detail next week)!

What if we want to do more complex layouts? Well we can use a different `LayoutManager`... but we can actually achieve a lot of flexibility simply by using _multiple containers_.

For example, we can make a `JPanel` object, which is basically an "empty" component. We can then add multiple buttons to this this panel, and add that panel to the `JFrame`. Because `JPanel` _is a_ `Component` (just like `JButton` is), we can use the `JPanel` exactly as we used the `JButton`---this panel just happens to have multiple buttons.

And since we can put any `Component` in a `JPanel`, and `JPanel` is itself a component... we can create nest these components together into a tree in an example of the [Composite Pattern](https://sourcemaking.com/design_patterns/composite). This allows us to create very complex user interfaces with just a simple `BoxLayout`!
- We'll see this kind of "nested" composite pattern in Android next week!
