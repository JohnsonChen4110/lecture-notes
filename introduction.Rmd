# Introduction

Start off with a question: _What is Android?_ Why did you sign up for a course called Android Development?

It's an Operating System! That is, it's software that connects hardware to software and provides general services. More than that, it's a _mobile specific_ operating system.

"Android" also refers to "platform" (e.g., devices that use the OS) and the ecosystem that surrounds it. This includes the device manufacturers who use the platform, and the applications that can be built and run on this platform.

## Android History `r #20min`

Some brief history:

* 2003: founded by "Android Inc" to build mobile OS operating system (similar to what Symbian (Nokia) was doing)
* 2005: acquired by Google, who was looking to get into mobile
* 2007: Google announces [Open Handset Alliance](http://www.openhandsetalliance.com/), group of tech companies working together to develop "open standards"
	- Google; HTC, Samsung, Sony; T-Mobile, Sprint NTT DoCoMo; Broadcom, Nvidia, etc. Now 84 companies.
	- Note this is the same year the first iPhone came out!

* 2008: First Android device (HTC Dream / T-Mobile G1)
	- 528Mhz ARM chip; 256MB memory; 320x480 resolution capacitive touch; slide-out keyboard! A fun little device
* 2010: First Nexus device: Google-developed "flagship" devices
	- Nexus One: 1Gz Scorpion; 512MB memory; .37" 480x800 AMOLED capacitive touch
	- Comparison: iPhone 6S+ (1.85Ghz dual core ARMv8, 2GB RAM, 5.5" @ 1920x1080)
* 2014: Android One (low-cost for developing countries)
* 2015: Project Brillo, aiming for embedded devices

Android is incredibly popular! (see e.g., [here](https://www.netmarketshare.com/operating-system-market-share.aspx?qprid=10&qpcustomd=0), [here](http://www.theverge.com/2017/2/16/14634656/android-ios-market-share-blackberry-2016), [here](http://www.businessinsider.com/iphone-v-android-market-share-2014-5))

- There are some questions about what is counted... but what we care about is that there are _a lot_ of Android devices out there! More than that, there are a lot of **different** devices!

For version history, reference the [Wiki chart](https://en.wikipedia.org/wiki/Android_version_history)
- Different "versions" are named after desserts. But from developer perspective, care about API version (e.g., what set of _interfaces_ are available).
- Interactive version: http://www.android.com/history/
- Usage breakdown at: http://developer.android.com/about/dashboards/index.html


Updates to devices historically through purchasing new devices (every 18m on average in US). Otherwise updates--including security updates--come through carriers. This is a problem from a consumer perspective! But Google working to change that; moving some services out of OS into separate "App" (Google Play Services).
- Android OS is "open source"; latest version at https://source.android.com/. Worth actually digging around in this sometime

Would be remiss if didn't mention some of the legal issues surrounding Android.

- Biggest is **Oracle v Google**: basics is that Oracle says the _Java API_ is copyright, so because Google uses that API is Android, Google is violating the copyright
	- Claim: the method signatures themselves (and how they work) are protected!
	- CA court decided for Google in 2012 (can't copyright an API!); reversed by Federal Circuit in 2014. Supreme Court refused to hear in 2015.
	- <https://www.eff.org/cases/oracle-v-google> for more Also <https://arstechnica.com/series/series-oracle-v-google/>
	- Interesting development: latest version of Android (Nougat) uses the [OpenJDK](http://openjdk.java.net/) implementation of Java, instead of Google own [see here](http://venturebeat.com/2015/12/29/google-confirms-next-android-version-wont-use-oracles-proprietary-java-apis/). Shouldn't impact us, but keep an eye out for potential differences between Android and Java SE.
- Others as well:
	- [Apple v Samsung](https://arstechnica.com/series/apple-v-samsung/): "You infringed our intellectual property!" ([Supreme court sides with Samsung](https://www.nytimes.com/2016/12/06/technology/samsung-apple-smartphone-patent-supreme-court.html?_r=0))
	- FairSearch v Google: "You're using predatory pricing!"

Take away: Android is a growing, evolving platform that is embedded in and affecting the social infrastructures around information technology.


## Android Architecture and Code `r #10min`
Let's consider the basic architecture of the Android platform (More details: https://source.android.com/devices/)

- Runs on a linux kernel (for interacting with memory, processor, etc)
- On top of that is the hardware abstraction layer: interface to drivers that let us access the hardware (camera, storage, wifi, etc)
	- These drivers are generally written in C
- But on top of that is the Runtime and Android Framework, which provides the Java language that we all know and love!
- (We'll be developing applications that interact with the Framework, which runs on Java).

There are two languages we'll be working with in this class:

1. **Java**. Android code (the logic, control, data stuff) is written in Java.
	- This will feel a lot like every other Java Program: you write classes, define methods, instantiate objects, and call methods on those objects
	- But we're working within a **framework**: a set of code _already exists_ to call specific methods: we'll just fill in what those methods do to run our code
		- More Angular (framework) than jQuery (library)
	- Important: This course expects you to have "journeyman"-level skills in Java (apprenticeship done, not yet master). We'll be using a number of intermediate concepts (like generics and inheritance) without much fanfare or explanation. And so you should be comfortable with that. If you're not... this class is going to be a challenge. Consider yourselves warned.
		- We will go over some of the topics that people reported being less familiar with tomorrow in lab... but that will be most our Java review. I'm assuming you're already comfortable with the language so that we can focus on the framework.
		- _By the way_: for reviewing; rather do a "work through a tutorial/explanation" or have me lecture/review topics? (e.g., do you want to drive or do you want me to?)
	- Any questions/concerns/issues about that

2. **XML**. Android interfaces and resources are specified in XML (eXtensible Markup Language). So we'll be doing a lot of XML writing.
	- XML is just like HTML, but you get to make up your own tags (though we're going to use the ones that Android made up).
	- If you've never worked with HTML... you'll pick it up fast (it's not complex).

If you think of web programming: the XML is going to contain what we would put in our HTML/CSS, and the Java will contain what would go in our JavaScript.

Building Apps: So we write code in Java & XML. How does that get run on the phone's hardware?

- Pre-Lollipop (5.0): used [Dalvik](https://en.wikipedia.org/wiki/Dalvik_(software)), a virtual machine (similar to the JVM from Java SE)
	- Java code --compile--> JVM bytecode --translated--> DVM bytecode
		- stored in DEX or ODEX files ("[optimized] Dalvik executables")
		- process is called "dexing" (so code is "dexed")
	- For CS people: Dalvik register-based architecture (not stack-based!)
	- Dalvik Includes JIT compilation to native code (like the [Java HotSpot](http://www.oracle.com/technetwork/articles/javase/index-jsp-136373.html))
		- _Why would "native code" be faster?_ Because no translation step is needed to talk to the actual hardware (the OS)
- Post-Lollipop (5.0): uses [Android Runtime (ART)](https://source.android.com/devices/tech/dalvik/)
	- compile into native code on installation! ("Ahead of Time" AOT)
	- accepts DEX bytecode for backwards compatibility
	- faster execution, but longer install time

Android applications are packaged into APK files (basically zip files)

- Which are then "side-loaded" or cryptographically signed to be uploaded to the App Store.
	- these are the "executable" versions of your program!
- Note: application frameworks are pre-DEXed (compiled) on device; actually compiling against empty stubs!
	- But any other libraries you include are copied into the app code.

So when building an App...

1. Generate Java source files (e.g., from resource files, which are written XML used to generate Java code)
2. Compile Java code into JVM bytecode
3. "dex" the JVM bytecode into Dalvik bytecode
4. Pack in assets and graphics into an APK
5. Cryptographically sign the APK file to verify it

There are a lot of steps here, but there are tools that take care of it for us. We'll just write Java and XML code and run a "build" script to do all of the steps.


## Development Tools `r #10min`
Since we're writing code for a virtual machine anyway, we can build Android apps on any computer OS (unlike some other mobile OS)

- Physical devices are the best--you'll need USB cable to be able to wire your device into your computer.
	- Any device should be fine; don't need cell service (just WiFi mostly)
	- If you don't normally use an Android phone, play around with it a bit to get use to the interaction language. E.g., how to click/swipe/drag/long-click things.
	- Turn on [developer options](http://developer.android.com/tools/device.html)!
- Also can use the Emulator (a "virtual" android device)
	- Represents a generic device with hardware you can specify... but has some limitations!
	- But the emulator not great on Windows; recommend you use Mac or a physical device
	- Make sure to use the HAXM (Intel acceleration manager!)
	- I'll be doing this for lecture demos (will keep me running slower than you!)

### Software
The software used to develop Android applications include:

- Java 7 **SDK**
- [Gradle](https://gradle.org/) or [Apache ANT](http://ant.apache.org/)
	- These are automated build tools--in effect, they let you specify a command that will do a bunch of steps (e.g., compilation, moving, etc) at once. These are how we make the "build script" to do those 5 building steps from earlier.
	- ANT is the old way, but Gradle is the new hotness
	- You'll be using Gradle for first homework (Java review), and we'll be poking at it periodically through the course.
		- We'll be doing minor tweaks to build files, not learning the entirety of the gradle build system (though as you get into professional development systems you'll want to check them out)
- Finally, the [Android Studio & SDK](http://developer.android.com/sdk/index.html).
	- This is our IDE and build system (everything else goes to support this).
	- Make sure the SDK command-line tools are installed!
		- put `tools` and `platform-tools` on the `PATH`
		- run `adb` to check
- SDK [Tools](http://developer.android.com/tools/help/index.html) include:
	- _deprecated_ `android`: does SDK/AVD (virtual device) work. Basically IDE commands, but from command-line
	- `emulator` runs the emulator
	- `adb` "Android Device Bridge"; connection between your computer and the device (physical _or_ virtual). Used for console output!
	- all of these are built into IDE, but command-line is a good fall-back!


## Hello World `r #30min`
In time remaining, lets get an App up and running and see what we actually will be working with! You will need to have Android Studio installed for this to work.

1. Launch Android Studio if you have it (may take a few minutes to open)
2. Start a new project!
	- use uwnetid in domain
	- note project location! Desktop is good for now
	- Target: this is the "minimum" SDK you support. Going to target Ice Cream Sandwich (4.0.3) for most this class. This is the earliest version we'll support.
		- Note that this is different than the "target SDK", which is the version you tested on! We'll adjust this in a moment, and will test on API 21 (Lollipop).
		- If you're testing on a physical device running older version, you can target that. But we'll grade at the 5.0 target.
3. Select an Empty Activity
	- Activities are "Screens" in your application (things the user can do). We'll talk more about this on Wednesday.
4. And boom, have an Android app! Aren't frameworks lovely?

### The Emulator
We can run our app by clicking the "Play" or "Run" button. We will need to define a device, so let's make an emulator!

- Nexus 5 is a good choice for supporting "older" devices. Pixel is also reasonable.
	- Use Lollipop, Google APIs, x86!
	- Snapshot to speed up loading
- Specify **hardware keyboard**
- Want to go in and edit it (`Tools > Android > AVD Manager`) so it accepts keyboard input!

Can slide to unlock, and there is our app!

### Project Contents
So what does our app look like in code? What do we have?

Note that Android Studio by default shows the "Android" view, which organizes files thematically. If you got the "Project" view you can see what the actual file system looks like.

- `app/` folder contains our application
	- `manifests/` contains the **Android Manifest** files, which is sort of like a "config" file for the app
	- `java/` contains the Java source code for your project
		- And we can find the `MyActivity` file in here
	- `res/` contains resource files used in the app. These are where we're going to put layout/appearance information
- Also have the `Gradle` scripts. There are a lot of these:
	- `build.gradle`: Top-level Gradle build; project-level (for building!)
	- `app/build.gradle`: Gradle build specific to the app **use this one to customize project!**
		- we can change the target SDK here!
	- `proguard-rules.pro`: config for release version (minimization, obfuscation, etc).
	- `gradle.properties`: Gradle-specific build settings, shared
	- `local.properties`: settings local to this machine only
	- `settings.gradle`: Gradle-specific build settings, shared
	- ANT would give:
		- `build.xml`: Ant build script integrated with Android SDK
		- `build.properties`: settings used for build across all machines
		- `local.properties`: settings local to this machine only
		- We're using Gradle, but be aware of ANT stuff for legacy purposes
- `res` has resource files. These are **XML** files that specify details of the app--such as layout.
	- `res/drawable/` : graphics (PNG, JPEG, etc)
	- `res/layout/` : UI XML layout files
	- `res/mipmap/` : launcher icon files
		- fun fact: MIP comes from "multum in parvo", latin for "much in little". Map cause image mapping
	- `res/values/` : general constants
	- See also: http://developer.android.com/guide/topics/resources/available-resources.html
		- We'll talk about these more next week!

Let's look at what the application does. We'll revisit this on Wednesday, but this will let us start seeing how the framework is structured.

- We start with the **Activity** Java source
	- We extend [`Activity`](http://developer.android.com/reference/android/app/Activity.html) (actually a subclass that supports Material Design stuff), making our own customizations.
- Override `onCreate()` method that is called by the framework when the Activity starts (more on lifecycle tomorrow).
	- Call super, and then `setContentView` to specify what the content (appearance) of our activity is.
	- Passing in a value from something called `R`. What _type_ of thing is this? (It's a class!)
	- `R` is a class that is **generated at compile time** and contains constants that are defined by the "resource" files!
		- Those files are converted into Java variables, which we access through the `R` class.
- `R.layout` refers to the "layouts" resource, so can go there.
	- Can open then up in "design" view. This lets you use GUIs to lay out your application (like a powerpoint slide). But frowned upon--much cleaner/nicer to write it out in code.
		- Same difference between writing your own HTML and using FrontPage or DreamWeaver or Wix. Legit, but less nice.
	- We can see the XML: tags, attributes, values. Tags nested inside one another.
	- Defines a layout, and inside that is a TextView (view of some of text), which has a value--text!
		- Can change that, and re-run the app!
	- If time: can also define this in `values/strings` (e.g., as a constant, refer to as `@string/message`)
- We'll talk about the layout and using these resources _A LOT_ more next week.
- If time: we can also set an icon! (`File > New > Image Asset`)
